import React from 'react';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var queries = [];
var cancelledError = {};
var globalStateListeners = [];
var uid = 0;
var configContext = React.createContext();
var isServer = typeof window === 'undefined';
var defaultConfig = {
  retry: 3,
  retryDelay: function retryDelay(attemptIndex) {
    return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
  },
  staleTime: 0,
  cacheTime: 5 * 60 * 1000,
  refetchAllOnWindowFocus: true,
  refetchInterval: false,
  suspense: false,
  queryKeySerializerFn: defaultQueryKeySerializerFn
};

var onWindowFocus = function onWindowFocus() {
  var _defaultConfig = defaultConfig,
      refetchAllOnWindowFocus = _defaultConfig.refetchAllOnWindowFocus;

  if (isDocumentVisible() && isOnline()) {
    refetchAllQueries({
      shouldRefetchQuery: function shouldRefetchQuery(query) {
        if (typeof query.config.refetchOnWindowFocus === 'undefined') {
          return refetchAllOnWindowFocus;
        } else {
          return query.config.refetchOnWindowFocus;
        }
      }
    })["catch"](function (error) {
      console.error(error.message);
    });
  }
};

var removePreviousHandler;
function setFocusHandler(callback) {
  // Unsub the old watcher
  if (removePreviousHandler) {
    removePreviousHandler();
  } // Sub the new watcher


  removePreviousHandler = callback(onWindowFocus);
}
setFocusHandler(function (handleFocus) {
  // Listen to visibillitychange and focus
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('visibilitychange', handleFocus, false);
    window.addEventListener('focus', handleFocus, false);
    return function () {
      // Be sure to unsubscribe if a new handler is set
      window.removeEventListener('visibilitychange', handleFocus);
      window.removeEventListener('focus', handleFocus);
    };
  }
});
function ReactQueryConfigProvider(_ref) {
  var config = _ref.config,
      children = _ref.children;
  var configContextValue = React.useContext(configContext);
  var newConfig = React.useMemo(function () {
    return _objectSpread2({}, configContextValue || defaultConfig, {}, config);
  }, [config, configContextValue]);

  if (!configContextValue) {
    defaultConfig = newConfig;
  }

  return React.createElement(configContext.Provider, {
    value: newConfig
  }, children);
}

function useConfigContext() {
  return React.useContext(configContext) || defaultConfig;
}

function makeQuery(options) {
  var initialData = options.config.paginated ? [] : null;

  if (typeof options.config.initialData !== 'undefined') {
    initialData = options.config.initialData;
  }

  var query = _objectSpread2({}, options, {
    pageVariables: [],
    instances: [],
    state: {
      error: null,
      isFetching: false,
      isFetchingMore: false,
      canFetchMore: false,
      failureCount: 0,
      isCached: false,
      isStale: true,
      data: initialData
    } // promise: null,
    // staleTimeout: null,
    // cacheTimeout: null,
    // cancelled: null,

  });

  query.setState = function (updater) {
    query.state = functionalUpdate(updater, query.state);
    query.instances.forEach(function (instance) {
      instance.onStateUpdate(query.state);
    });
    globalStateListeners.forEach(function (d) {
      return d();
    });
  };

  query.subscribe = function (instance) {
    var found = query.instances.find(function (d) {
      return d.id === instance.id;
    });

    if (found) {
      Object.assign(found, instance);
    } else {
      found = instance;
      query.instances.push(instance);
    } // Mark as active


    query.setState(function (old) {
      return _objectSpread2({}, old, {
        isInactive: false
      });
    }); // Cancel garbage collection

    clearTimeout(query.cacheTimeout); // Mark the query as not cancelled

    query.cancelled = null; // Return the unsubscribe function

    return function () {
      query.instances = query.instances.filter(function (d) {
        return d.id !== instance.id;
      });

      if (!query.instances.length) {
        // Cancel any side-effects
        query.cancelled = cancelledError;
        query.cancelQueries(); // Mark as inactive

        query.setState(function (old) {
          return _objectSpread2({}, old, {
            isInactive: true
          });
        }); // Schedule garbage collection

        query.cacheTimeout = setTimeout(function () {
          queries.splice(queries.findIndex(function (d) {
            return d === query;
          }), 1);
          globalStateListeners.forEach(function (d) {
            return d();
          });
        }, query.state.isCached ? query.config.cacheTime : 0);
      }
    };
  }; // Set up the fetch function


  var tryFetchQueryPages =
  /*#__PURE__*/
  function () {
    var _ref2 = _asyncToGenerator(function* (pageVariables) {
      try {
        // Perform the query
        var promises = pageVariables.map(function (variables) {
          return query.queryFn(variables);
        });

        query.cancelQueries = function () {
          return promises.map(function (_ref3) {
            var cancel = _ref3.cancel;
            return cancel && cancel();
          });
        };

        var data = yield Promise.all(promises);
        if (query.cancelled) throw query.cancelled;
        return data;
      } catch (error) {
        if (query.cancelled) throw query.cancelled; // If we fail, increase the failureCount

        query.setState(function (old) {
          return _objectSpread2({}, old, {
            failureCount: old.failureCount + 1
          });
        }); // Do we need to retry the request?

        if ( // Only retry if the document is visible
        query.config.retry === true || query.state.failureCount < query.config.retry) {
          if (!isDocumentVisible()) {
            return new Promise(function (r) {});
          } // Determine the retryDelay


          var delay = functionalUpdate(query.config.retryDelay, query.state.failureCount); // Return a new promise with the retry

          return new Promise(function (resolve, reject) {
            // Keep track of the retry timeout
            setTimeout(
            /*#__PURE__*/
            _asyncToGenerator(function* () {
              if (query.cancelled) return reject(query.cancelled);

              try {
                var _data = yield tryFetchQueryPages(pageVariables);

                if (query.cancelled) return reject(query.cancelled);
                resolve(_data);
              } catch (error) {
                if (query.cancelled) return reject(query.cancelled);
                reject(error);
              }
            }), delay);
          });
        }

        throw error;
      }
    });

    return function tryFetchQueryPages(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  query.fetch =
  /*#__PURE__*/
  _asyncToGenerator(function* () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$variables = _ref6.variables,
        variables = _ref6$variables === void 0 ? query.config.paginated && query.state.isCached ? query.pageVariables : query.variables : _ref6$variables,
        force = _ref6.force,
        isFetchMore = _ref6.isFetchMore;

    // Don't refetch fresh queries without force
    if (!query.queryHash || !query.state.isStale && !force) {
      return;
    } // Create a new promise for the query cache if necessary


    if (!query.promise) {
      query.promise = _asyncToGenerator(function* () {
        // If there are any retries pending for this query, kill them
        query.cancelled = null;

        var cleanup = function cleanup() {
          delete query.promise; // Schedule a fresh invalidation, always!

          clearTimeout(query.staleTimeout);
          query.staleTimeout = setTimeout(function () {
            if (query) {
              query.setState(function (old) {
                return _objectSpread2({}, old, {
                  isStale: true
                });
              });
            }
          }, query.config.staleTime);
          query.setState(function (old) {
            return _objectSpread2({}, old, {
              isFetching: false,
              isFetchingMore: false
            });
          });
        };

        try {
          // Set up the query refreshing state
          query.setState(function (old) {
            return _objectSpread2({}, old, {
              isFetching: true,
              isFetchingMore: isFetchMore,
              failureCount: 0
            });
          });
          variables = query.config.paginated && query.state.isCached && !isFetchMore ? variables : [variables]; // Try to fetch

          var data = yield tryFetchQueryPages(variables); // If we are paginating, and this is the first query or a fetch more
          // query, then store the variables in the pageVariables

          if (query.config.paginated && (isFetchMore || !query.state.isCached)) {
            query.pageVariables.push(variables[0]);
          } // Set data and mark it as cached


          query.setState(function (old) {
            data = query.config.paginated ? isFetchMore ? [].concat(_toConsumableArray(old.data), [data[0]]) : data : data[0];
            return _objectSpread2({}, old, {
              error: null,
              data: data,
              isCached: true,
              isStale: false
            }, query.config.paginated && {
              canFetchMore: query.config.getCanFetchMore(data[data.length - 1], data)
            });
          });
          query.instances.forEach(function (instance) {
            return instance.onSuccess && instance.onSuccess(query.state.data);
          });
          cleanup();
          return data;
        } catch (error) {
          // As long as it's not a cancelled retry
          cleanup();

          if (error !== query.cancelled) {
            // Store the error
            query.setState(function (old) {
              return _objectSpread2({}, old, {
                error: error,
                isCached: false,
                isStale: true
              });
            });
            query.instances.forEach(function (instance) {
              return instance.onError && instance.onError(error);
            });
            throw error;
          }
        }
      })();
    }

    return query.promise;
  });

  query.setData = function (updater) {
    return query.setState(function (old) {
      return _objectSpread2({}, old, {
        data: functionalUpdate(updater, old.data)
      });
    });
  };

  return query;
}

function useQuery(queryKey, queryFn) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var isMountedRef = React.useRef(false);
  var wasSuspendedRef = React.useRef(false);
  var instanceIdRef = React.useRef(uid++);
  var instanceId = instanceIdRef.current;
  config = _objectSpread2({}, useConfigContext(), {}, config);
  var _config = config,
      manual = _config.manual;

  var _config$queryKeySeria = config.queryKeySerializerFn(queryKey),
      _config$queryKeySeria2 = _slicedToArray(_config$queryKeySeria, 4),
      queryHash = _config$queryKeySeria2[0],
      queryGroup = _config$queryKeySeria2[1],
      variablesHash = _config$queryKeySeria2[2],
      variables = _config$queryKeySeria2[3];

  var query = queries.find(function (query) {
    return query.queryHash === queryHash;
  });
  var wasPrefetched;

  if (query) {
    wasPrefetched = query.config.prefetch;
    query.config = config;

    if (!isMountedRef.current) {
      query.config.prefetch = wasPrefetched;
    }

    query.queryFn = queryFn;
  } else {
    query = makeQuery({
      queryHash: queryHash,
      queryGroup: queryGroup,
      variablesHash: variablesHash,
      variables: variables,
      config: config,
      queryFn: queryFn
    });

    if (!isServer) {
      queries.push(query);
    }
  }

  React.useEffect(function () {
    if (config.refetchInterval && !query.refetchInterval) {
      query.refetchInterval = setInterval(function () {
        if (isDocumentVisible() || config.refetchIntervalInBackground) {
          query.fetch();
        }
      }, config.refetchInterval);
      return function () {
        clearInterval(query.refetchInterval);
        query.refetchInterval = null;
      };
    }
  }, [config.refetchInterval, config.refetchIntervalInBackground, query]);

  var _React$useState = React.useState(query.state),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      state = _React$useState2[0],
      setState = _React$useState2[1];

  var onStateUpdate = React.useCallback(function (newState) {
    return setState(newState);
  }, []);
  var getLatestOnError = useGetLatest(config.onError);
  var getLatestOnSuccess = useGetLatest(config.onSuccess);
  React.useEffect(function () {
    var unsubscribeFromQuery = query.subscribe({
      id: instanceId,
      onStateUpdate: onStateUpdate,
      onSuccess: function onSuccess(data) {
        return getLatestOnSuccess() && getLatestOnSuccess()(data);
      },
      onError: function onError(err) {
        return getLatestOnError() && getLatestOnError()(err);
      }
    });
    return unsubscribeFromQuery;
  }, [getLatestOnError, getLatestOnSuccess, instanceId, onStateUpdate, query]);
  var isLoading = !state.isCached && query.state.isFetching;
  var refetch = query.fetch;
  var setData = query.setData;
  var fetchMore = React.useCallback(config.paginated ? function (paginationVariables) {
    return query.fetch({
      variables: paginationVariables,
      force: true,
      isFetchMore: true
    });
  } : undefined, [query]);
  var getLatestManual = useGetLatest(manual);
  React.useEffect(function () {
    if (getLatestManual()) {
      return;
    }

    if (config.suspense) {
      if (wasSuspendedRef.current || wasPrefetched) {
        return;
      }
    }

    var runRefetch =
    /*#__PURE__*/
    function () {
      var _ref8 = _asyncToGenerator(function* () {
        try {
          yield query.fetch();
        } catch (err) {
          console.error(err); // Swallow this error. Don't rethrow it into a render function
        }
      });

      return function runRefetch() {
        return _ref8.apply(this, arguments);
      };
    }();

    runRefetch();
  }, [config.suspense, getLatestManual, query, wasPrefetched]);
  React.useEffect(function () {
    isMountedRef.current = true;
  }, []);

  if (config.suspense) {
    if (state.error) {
      throw state.error;
    }

    if (!state.isCached) {
      wasSuspendedRef.current = true;
      throw query.fetch();
    }
  }

  wasSuspendedRef.current = false;
  return _objectSpread2({}, state, {
    isLoading: isLoading,
    refetch: refetch,
    fetchMore: fetchMore,
    setData: setData
  });
}
function prefetchQuery(_x2, _x3) {
  return _prefetchQuery.apply(this, arguments);
}

function _prefetchQuery() {
  _prefetchQuery = _asyncToGenerator(function* (queryKey, queryFn) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    config = _objectSpread2({}, defaultConfig, {}, config, {
      prefetch: true
    });

    var _defaultConfig$queryK3 = defaultConfig.queryKeySerializerFn(queryKey),
        _defaultConfig$queryK4 = _slicedToArray(_defaultConfig$queryK3, 4),
        queryHash = _defaultConfig$queryK4[0],
        queryGroup = _defaultConfig$queryK4[1],
        variablesHash = _defaultConfig$queryK4[2],
        variables = _defaultConfig$queryK4[3]; // If we're prefetching, use the queryFn to make the fetch call


    var query = queries.find(function (query) {
      return query.queryHash === queryHash;
    });

    if (query) {
      if (!config.force) {
        return;
      }

      query.config = config;
      query.queryFn = queryFn;
    } else {
      query = makeQuery({
        queryHash: queryHash,
        queryGroup: queryGroup,
        variablesHash: variablesHash,
        variables: variables,
        config: config,
        queryFn: queryFn
      });

      if (!isServer) {
        queries.push(query);
      }
    } // Trigger a query subscription with one-time unique id


    var unsubscribeFromQuery = query.subscribe({
      id: uid++,
      onStateUpdate: function onStateUpdate() {}
    }); // Trigger a fetch and return the promise

    try {
      return yield query.fetch({
        force: config.force
      });
    } finally {
      // Since this is not a hook, upsubscribe after we're done
      unsubscribeFromQuery();
    }
  });
  return _prefetchQuery.apply(this, arguments);
}

function refetchQuery(_x4) {
  return _refetchQuery.apply(this, arguments);
}

function _refetchQuery() {
  _refetchQuery = _asyncToGenerator(function* (queryKey) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _defaultConfig$queryK5 = defaultConfig.queryKeySerializerFn(queryKey),
        _defaultConfig$queryK6 = _slicedToArray(_defaultConfig$queryK5, 4),
        queryGroup = _defaultConfig$queryK6[1],
        variablesHash = _defaultConfig$queryK6[2],
        variables = _defaultConfig$queryK6[3]; // If we're simply refetching an existing query, then go find them
    // and call their fetch functions


    if (!queryGroup) {
      return;
    }

    return Promise.all(queries.map(
    /*#__PURE__*/
    function () {
      var _ref16 = _asyncToGenerator(function* (query) {
        if (query.queryGroup !== queryGroup) {
          return;
        }

        if (variables === false && query.variablesHash) {
          return;
        }

        if (variablesHash && query.variablesHash !== variablesHash) {
          return;
        }

        yield query.fetch({
          force: config.force
        });
      });

      return function (_x6) {
        return _ref16.apply(this, arguments);
      };
    }()));
  });
  return _refetchQuery.apply(this, arguments);
}

function useMutation(mutationFn) {
  var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      refetchQueries = _ref9.refetchQueries,
      refetchQueriesOnFailure = _ref9.refetchQueriesOnFailure;

  var _React$useState3 = React.useState(null),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      data = _React$useState4[0],
      setData = _React$useState4[1];

  var _React$useState5 = React.useState(null),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      error = _React$useState6[0],
      setError = _React$useState6[1];

  var _React$useState7 = React.useState(false),
      _React$useState8 = _slicedToArray(_React$useState7, 2),
      isLoading = _React$useState8[0],
      setIsLoading = _React$useState8[1];

  var mutationFnRef = React.useRef();
  mutationFnRef.current = mutationFn;
  var mutate = React.useCallback(
  /*#__PURE__*/
  function () {
    var _ref10 = _asyncToGenerator(function* (variables) {
      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          updateQuery = _ref11.updateQuery,
          _ref11$waitForRefetch = _ref11.waitForRefetchQueries,
          waitForRefetchQueries = _ref11$waitForRefetch === void 0 ? false : _ref11$waitForRefetch;

      setIsLoading(true);
      setError(null);

      var doRefetchQueries =
      /*#__PURE__*/
      function () {
        var _ref12 = _asyncToGenerator(function* () {
          var refetchPromises = refetchQueries.map(function (queryKey) {
            return refetchQuery(queryKey, {
              force: true
            });
          });

          if (waitForRefetchQueries) {
            yield Promise.all(refetchPromises);
          }
        });

        return function doRefetchQueries() {
          return _ref12.apply(this, arguments);
        };
      }();

      try {
        var res = yield mutationFnRef.current(variables);
        setData(res);

        if (updateQuery) {
          setQueryData(updateQuery, res, {
            shouldRefetch: false
          });
        }

        if (refetchQueries) {
          try {
            yield doRefetchQueries();
          } catch (err) {
            console.error(err); // Swallow this error since it is a side-effect
          }
        }

        setIsLoading(false);
        return res;
      } catch (error) {
        setError(error);

        if (refetchQueriesOnFailure) {
          yield doRefetchQueries();
        }

        setIsLoading(false);
        throw error;
      }
    });

    return function (_x5) {
      return _ref10.apply(this, arguments);
    };
  }(), [refetchQueriesOnFailure, refetchQueries]);
  return [mutate, {
    data: data,
    isLoading: isLoading,
    error: error
  }];
}
function useIsFetching() {
  var _React$useState9 = React.useState({}),
      _React$useState10 = _slicedToArray(_React$useState9, 2),
      state = _React$useState10[0],
      setState = _React$useState10[1];

  var ref = React.useRef();

  if (!ref.current) {
    ref.current = function () {
      setState({});
    };

    globalStateListeners.push(ref.current);
  }

  React.useEffect(function () {
    return function () {
      globalStateListeners = globalStateListeners.filter(function (d) {
        return d !== ref.current;
      });
    };
  }, []);
  return React.useMemo(function () {
    return state && queries.some(function (query) {
      return query.state.isFetching;
    });
  }, [state]);
}
function setQueryData(userQueryKey, updater) {
  var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref13$shouldRefetch = _ref13.shouldRefetch,
      shouldRefetch = _ref13$shouldRefetch === void 0 ? true : _ref13$shouldRefetch;

  var _defaultConfig$queryK = defaultConfig.queryKeySerializerFn(userQueryKey),
      _defaultConfig$queryK2 = _slicedToArray(_defaultConfig$queryK, 1),
      queryHash = _defaultConfig$queryK2[0];

  if (!queryHash) {
    return;
  }

  var query = queries.find(function (d) {
    return d.queryHash === queryHash;
  });

  if (!query) {
    return;
  }

  query.setData(updater);

  if (shouldRefetch) {
    return refetchQuery(userQueryKey);
  }
}
function refetchAllQueries() {
  return _refetchAllQueries.apply(this, arguments);
}

function _refetchAllQueries() {
  _refetchAllQueries = _asyncToGenerator(function* () {
    var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        includeInactive = _ref14.includeInactive,
        _ref14$force = _ref14.force,
        force = _ref14$force === void 0 ? includeInactive : _ref14$force,
        shouldRefetchQuery = _ref14.shouldRefetchQuery;

    return Promise.all(queries.map(
    /*#__PURE__*/
    function () {
      var _ref17 = _asyncToGenerator(function* (query) {
        if (typeof shouldRefetchQuery !== 'undefined' && !shouldRefetchQuery(query)) {
          return;
        }

        if (query.instances.length || includeInactive) {
          return query.fetch({
            force: force
          });
        }
      });

      return function (_x7) {
        return _ref17.apply(this, arguments);
      };
    }()));
  });
  return _refetchAllQueries.apply(this, arguments);
}

function clearQueryCache() {
  queries.length = 0;
}

function defaultQueryKeySerializerFn(queryKey) {
  if (!queryKey) {
    return [];
  }

  if (typeof queryKey === 'function') {
    try {
      return defaultQueryKeySerializerFn(queryKey());
    } catch (_unused) {
      return [];
    }
  }

  if (Array.isArray(queryKey)) {
    var _queryKey = _slicedToArray(queryKey, 2),
        id = _queryKey[0],
        variables = _queryKey[1];

    var variablesIsObject = isObject(variables);

    if (typeof id !== 'string' || variables && !variablesIsObject) {
      console.warn('Tuple queryKey:', queryKey);
      throw new Error("Invalid query key tuple type: [".concat(_typeof(id), ", and ").concat(_typeof(variables), "]"));
    }

    var variablesHash = variablesIsObject ? stableStringify(variables) : '';
    return ["".concat(id).concat(variablesHash ? "_".concat(variablesHash, "}") : ''), id, variablesHash, variables];
  }

  return [queryKey, queryKey];
}

function stableStringifyReplacer(_, value) {
  return isObject(value) ? Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.keys(value).sort().map(function (key) {
    return _defineProperty({}, key, value[key]);
  })))) : Array.isArray(value) ? value : String(value);
}

function stableStringify(obj) {
  return JSON.stringify(obj, stableStringifyReplacer);
}

function isObject(a) {
  return a && _typeof(a) === 'object' && !Array.isArray(a);
}

function isDocumentVisible() {
  return typeof document === 'undefined' || document.visibilityState === undefined || document.visibilityState === 'visible' || document.visibilityState === 'prerender';
}

function isOnline() {
  return navigator.onLine === undefined || navigator.onLine;
}

function useGetLatest(obj) {
  var ref = React.useRef();
  ref.current = obj;
  return React.useCallback(function () {
    return ref.current;
  }, []);
}

function functionalUpdate(updater, old) {
  return typeof updater === 'function' ? updater(old) : updater;
}

export { ReactQueryConfigProvider, clearQueryCache, globalStateListeners, prefetchQuery, queries, refetchAllQueries, refetchQuery, setFocusHandler, setQueryData, stableStringify, useIsFetching, useMutation, useQuery };
//# sourceMappingURL=index.es.js.map
